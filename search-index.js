var N=null,E="",T="t",U="u",searchIndex={};
var R=["An abstract description of a value: if it is public or…","haybale_pitchfork","haybale_pitchfork::CompleteAbstractData","haybale_pitchfork::ConstantTimeResultForPath","backend","project","config","constanttimeresultforfunction","abstractvalue","A (public) pointer to this struct's parent. E.g., in the C…","A (first-class) array of values","When C code uses `void*`, this often becomes `i8*` in…","Use the given `data`, even though it may not match the…","Use the given `data`, but also (during initialization) add…","an 8-bit public value","a 16-bit public value","a 32-bit public value","a 64-bit public value","pub_integer","a public value with the given number of bits","an 8-bit secret value","a 16-bit secret value","a 32-bit secret value","a 64-bit secret value","sec_integer","a secret value with the given number of bits","pub_pointer_to","A (public) pointer to something - another value, an array,…","pub_maybe_null_pointer_to","A (public) pointer which may either point to the given…","pub_pointer_to_func","a (public) pointer to the LLVM `Function` with the given…","pub_pointer_to_hook","a (public) pointer to the hook registered for the given name","pub_pointer_to_self","A (public) pointer to this struct itself. E.g., in the C…","pub_pointer_to_parent","pub_pointer_to_parent_or","Like `pub_pointer_to_parent()`, but if the parent is not…","array_of","A (first-class) structure of values","unconstrained_pointer","A (public) pointer which may point anywhere, including…","void_override","same_size_override","abstractdata","with_watchpoint","POINTER_SIZE_BITS","structdescriptions","completeabstractdata","operand","result","haybale_pitchfork::secret","haybale_pitchfork::secret::BV","option","constanttimeresultforpath","try_from","try_into","borrow_mut","to_owned","clone_into","type_id","to_string","borrow","typeid","string","haybale_pitchfork::allocation","initializationcontext","btorref","formatter","bvsolution","get_solver","duration","Construct a new `Project` from a path to a directory…","ConstantTimeResultForFunction","PathStatistics","CompleteAbstractData","AbstractValue","ConstantTimeResultForPath","AbstractData","InitializationContext"];

searchIndex["haybale_pitchfork"]={"doc":E,"i":[[3,"Config",R[1],"Various settings which affect how the symbolic execution…",N,N],[12,"loop_bound",E,"Maximum number of times to execute any given line of LLVM…",0,N],[12,"solver_query_timeout",E,"Maximum amount of time to allow for any single solver query.",0,N],[12,"null_detection",E,"If `true`, all memory accesses will be checked to ensure…",0,N],[12,"concretize_memcpy_lengths",E,"When encountering a `memcpy`, `memset`, or `memmove` with…",0,N],[12,"squash_unsats",E,"`Error::Unsat` is an error type which is used internally,…",0,N],[12,"trust_llvm_assumes",E,"When encountering the `llvm.assume()` intrinsic, should we…",0,N],[12,"function_hooks",E,"The set of currently active function hooks; see…",0,N],[12,"initial_mem_watchpoints",E,"The initial memory watchpoints when a `State` is created…",0,N],[12,"demangling",E,"Controls the (attempted) demangling of function names in…",0,N],[12,"print_source_info",E,"If `true`, then `haybale` will attempt to print source…",0,N],[12,"print_module_name",E,"If `true`, then `haybale` will include the module name…",0,N],[3,"Project",E,"A `Project` is a collection of LLVM code to be explored,…",N,N],[3,R[79],E,R[0],N,N],[3,R[74],E,E,N,N],[12,"funcname",E,"Name of the toplevel function we analyzed",1,N],[12,"path_results",E,"the `ConstantTimeResultForPath`s for each path in that…",1,N],[12,"block_coverage",E,"Map from function names to statistics on the block…",1,N],[3,R[75],E,E,N,N],[12,"num_ct_paths",E,"How many paths \"passed\", that is, had no error or…",2,N],[12,"num_ct_violations",E,"How many constant-time violations did we find",2,N],[12,"num_unsats",E,"How many Unsat errors did we find",2,N],[12,"num_loop_bound_exceeded",E,"How many LoopBoundExceeded errors did we find",2,N],[12,"num_null_ptr_deref",E,"How many NullPointerDereference errors did we find",2,N],[12,"num_function_not_found",E,"How many FunctionNotFound errors did we find",2,N],[12,"num_solver_errors",E,"How many solver errors (including timeouts) did we find",2,N],[12,"num_unsupported_instruction",E,"How many UnsupportedInstruction errors did we find",2,N],[12,"num_malformed_instruction",E,"How many MalformedInstruction errors did we find",2,N],[12,"num_other_errors",E,"How many other errors (including solver timeouts) did we…",2,N],[4,R[76],E,R[0],N,N],[13,"PublicValue",E,"A public value, of the given size in bits. The…",3,N],[12,"bits",R[2],E,3,N],[12,"value",E,E,3,N],[13,"Secret",R[1],"A secret value (pointer or non-pointer, doesn't matter) of…",3,N],[12,"bits",R[2],E,3,N],[13,"Array",R[1],R[10],3,N],[12,"element_type",R[2],E,3,N],[12,"num_elements",E,E,3,N],[13,"Struct",R[1],R[40],3,N],[12,"name",R[2],E,3,N],[12,"elements",E,E,3,N],[13,"PublicPointerTo",R[1],R[27],3,N],[12,"pointee",R[2],"Description of the thing being pointed to",3,N],[12,"maybe_null",E,"If `false`, the pointer must point to the pointee; if…",3,N],[13,"PublicPointerToFunction",R[1],"A (public) pointer to the LLVM `Function` with the given…",3,N],[13,"PublicPointerToHook",E,"A (public) pointer to the hook registered for the given name",3,N],[13,"PublicPointerToSelf",E,R[35],3,N],[13,"PublicPointerToParentOr",E,R[9],3,N],[13,"VoidOverride",E,R[11],3,N],[12,"llvm_struct_name",R[2],E,3,N],[12,"data",E,E,3,N],[13,"SameSizeOverride",R[1],R[12],3,N],[12,"data",R[2],E,3,N],[13,"WithWatchpoint",R[1],R[13],3,N],[12,"name",R[2],E,3,N],[12,"data",E,E,3,N],[4,R[77],R[1],E,N,N],[13,"ExactValue",E,"This exact numerical value",4,N],[13,"Range",E,"Any numerical value in the range (inclusive)",4,N],[13,"Unconstrained",E,"Any value whatsoever",4,N],[13,"Named",E,"A value with a (unique) name, so that it can be referenced…",4,N],[12,"name","haybale_pitchfork::AbstractValue",E,4,N],[12,"value",E,E,4,N],[13,"EqualTo",R[1],"A value equal to the value with the given name",4,N],[13,"SignedLessThan",E,"A value signed-less-than the value with the given name",4,N],[13,"SignedGreaterThan",E,"A value signed-greater-than the value with the given name",4,N],[13,"UnsignedLessThan",E,"A value unsigned-less-than the value with the given name",4,N],[13,"UnsignedGreaterThan",E,"A value unsigned-greater-than the value with the given name",4,N],[4,R[78],E,E,N,N],[13,"IsConstantTime",E,E,5,N],[13,"NotConstantTime",E,E,5,N],[12,"violation_message",R[3],"A `String` describing the violation found on this path.",5,N],[13,"OtherError",R[1],E,5,N],[12,"error",R[3],"The `Error` encountered on this path.",5,N],[12,"full_message",E,"The full error message with \"rich context\" (backtrace,…",5,N],[5,"check_for_ct_violation_in_inputs",R[1],"Checks whether a function is \"constant-time\" in its…",N,[[["str"],[R[5]],[R[6],[R[4]]],[R[4]],["bool"]],[R[7]]]],[5,"check_for_ct_violation",E,"Checks whether a function is \"constant-time\" in the…",N,[[["str"],[R[5]],[R[48]],[R[4]],[R[6],[R[4]]],["bool"]],[R[7]]]],[11,"pub_i8",E,R[14],3,[[[R[8]]],["self"]]],[11,"pub_i16",E,R[15],3,[[[R[8]]],["self"]]],[11,"pub_i32",E,R[16],3,[[[R[8]]],["self"]]],[11,"pub_i64",E,R[17],3,[[[R[8]]],["self"]]],[11,R[18],E,R[19],3,[[[R[8]],["usize"]],["self"]]],[11,"sec_i8",E,R[20],3,[[],["self"]]],[11,"sec_i16",E,R[21],3,[[],["self"]]],[11,"sec_i32",E,R[22],3,[[],["self"]]],[11,"sec_i64",E,R[23],3,[[],["self"]]],[11,R[24],E,R[25],3,[[["usize"]],["self"]]],[11,R[26],E,"a (public) pointer to something - another value, an array,…",3,[[],["self"]]],[11,R[28],E,R[29],3,[[],["self"]]],[11,R[30],E,R[31],3,[[],["self"]]],[11,R[32],E,R[33],3,[[],["self"]]],[11,R[34],E,"a (public) pointer to this struct itself; see comments on…",3,[[],["self"]]],[11,R[36],E,R[9],3,[[],["self"]]],[11,R[37],E,R[38],3,[[],["self"]]],[11,R[39],E,R[10],3,[[["usize"]],["self"]]],[11,"_struct",E,"A (first-class) structure of values. Name used only for…",3,[[],["self"]]],[11,R[41],E,R[42],3,[[],["self"]]],[11,R[43],E,R[11],3,[[["str"],[R[54],["str"]]],["self"]]],[11,R[44],E,R[12],3,[[],["self"]]],[11,R[46],E,R[13],3,[[],["self"]]],[18,R[47],E,E,3,N],[11,"size_in_bits",E,"Get the size of the `CompleteAbstractData`, in bits",3,[[["self"]],["usize"]]],[11,"field_size_in_bits",E,"Get the size of the nth (0-indexed) field/element of the…",3,[[["self"],["usize"]],["usize"]]],[11,"offset_in_bits",E,"Get the offset of the nth (0-indexed) field/element of the…",3,[[["self"],["usize"]],["usize"]]],[11,"is_pointer",E,"Does the `CompleteAbstractData` represent a pointer of…",3,[[["self"]],["bool"]]],[11,"pointee_size_in_bits",E,"Get the size of the data this `CompleteAbstractData`…",3,[[["self"]],["usize"]]],[11,"pub_i8",E,R[14],6,[[[R[8]]],["self"]]],[11,"pub_i16",E,R[15],6,[[[R[8]]],["self"]]],[11,"pub_i32",E,R[16],6,[[[R[8]]],["self"]]],[11,"pub_i64",E,R[17],6,[[[R[8]]],["self"]]],[11,R[18],E,R[19],6,[[[R[8]],["usize"]],["self"]]],[11,"sec_i8",E,R[20],6,[[],["self"]]],[11,"sec_i16",E,R[21],6,[[],["self"]]],[11,"sec_i32",E,R[22],6,[[],["self"]]],[11,"sec_i64",E,R[23],6,[[],["self"]]],[11,R[24],E,R[25],6,[[["usize"]],["self"]]],[11,R[26],E,R[27],6,[[],["self"]]],[11,R[28],E,R[29],6,[[],["self"]]],[11,R[30],E,R[31],6,[[],["self"]]],[11,R[32],E,R[33],6,[[],["self"]]],[11,R[34],E,R[35],6,[[],["self"]]],[11,R[36],E,R[9],6,[[],["self"]]],[11,R[37],E,R[38],6,[[],["self"]]],[11,R[39],E,R[10],6,[[["usize"]],["self"]]],[11,"_struct",E,R[40],6,[[],["self"]]],[11,"default",E,"Just use the default structure based on the LLVM type…",6,[[],["self"]]],[11,"default_for_llvm_struct_name",E,"Use the default structure for the given LLVM struct name.",6,[[],["self"]]],[11,R[41],E,R[42],6,[[],["self"]]],[11,"unconstrained",E,"Just fill with the appropriate number of unconstrained…",6,[[],["self"]]],[11,"secret",E,"Fill with the appropriate number of secret bytes based on…",6,[[],["self"]]],[11,R[43],E,"See notes on `CompleteAbstractData::void_override`.",6,[[["str"],[R[45]],[R[54],["str"]]],["self"]]],[11,R[44],E,"See notes on `CompleteAbstractData::same_size_override`.",6,[[[R[45]]],["self"]]],[11,R[46],E,R[13],6,[[],["self"]]],[18,"DEFAULT_ARRAY_LENGTH",E,E,6,N],[18,R[47],E,E,6,N],[18,"OPAQUE_STRUCT_SIZE_BYTES",E,E,6,N],[11,"to_complete",E,"Fill in the default `CompleteAbstractData` for any parts…",6,[[[R[5]],[R[48]],["type"]],[R[49]]]],[11,"named",E,E,4,[[["str"],[R[8]]],["self"]]],[0,"allocation",E,E,N,N],[3,"Context",R[66],"This `Context` serves two purposes: first, simply…",N,N],[3,R[80],E,"As opposed to the `Context`, which contains global-ish…",N,N],[5,"allocate_args",E,"Allocate the function parameters given in `params` with…",N,[[[R[48]],[R[5]],["state"]],[[R[51],["vec"]],["vec",["bv"]]]]],[11,"new",E,E,7,[[["state"],[R[5]],[R[48]]],["self"]]],[11,"blank",E,"A default/blank initialization context. If you're not…",8,[[],["self"]]],[11,"initialize_data_in_memory",E,"Initialize the data in memory at `addr` according to the…",8,[[["type"],[R[49]],["bv"],["context"],[R[54],["type"]]],[[R[51],["usize"]],["usize"]]]],[0,"hook_helpers",R[1],"This module contains helper functions that may be useful…",N,N],[5,"fill_unconstrained_with_length","haybale_pitchfork::hook_helpers","This utility function fills a buffer with unconstrained…",N,[[["either",[R[50]]],["u32"],["state"],[R[50]],[R[65]]],[R[51]]]],[5,"fill_secret_with_length",E,"This utility function fills a buffer with secret data, and…",N,[[["either",[R[50],"bv"]],[R[50]],["bv"],["state"],["u32"],[R[65]]],[R[51]]]],[5,"allocate_and_init_abstractdata",E,"This helper function allocates space for the given…",N,[[[R[5]],["state"],[R[48]],[R[45]],["type"]],[["bv"],[R[51],["bv"]]]]],[5,"reinitialize_pointee",E,"This helper function reinitializes whatever is pointed to…",N,[[[R[5]],["state"],[R[50]],[R[45]],[R[48]]],[R[51]]]],[0,"secret",R[1],"The `BV`, `Memory`, and `Backend` in this module are…",N,N],[3,"BtorRef",R[52],"This wrapper around `Rc<Btor>` exists simply so we can…",N,N],[3,"Memory",E,E,N,N],[3,"Backend",E,E,N,N],[4,"BV",E,E,N,N],[13,"Public",E,E,9,N],[13,"Secret",E,"`Secret` values are opaque because we don't care about…",9,N],[12,"btor",R[53],E,9,N],[12,"width",E,E,9,N],[12,"symbol",E,E,9,N],[13,"PartiallySecret",R[52],"`PartiallySecret` values have some secret and some…",9,N],[12,"secret_mask",R[53],"A vector the length of the `PartiallySecret` value's…",9,N],[12,"data",E,"A `BV`, which must have bitwidth exactly equal to the…",9,N],[12,"symbol",E,E,9,N],[11,"is_secret",R[52],E,9,[[["self"]],["bool"]]],[11,"as_public",E,"Gets the value out of a `BV::Public`, panicking if it is…",9,[[["self"]],["bv"]]],[6,"StructDescriptions",R[1],"A map from struct name to an `AbstractData` description of…",N,N],[11,"first_ct_violation",E,"Return the `violation_message` for the first…",1,[[["self"]],[["str"],[R[54],["str"]]]]],[11,"first_error_or_violation",E,"Return the first `NotConstantTime` or `OtherError` result…",1,[[["self"]],[[R[54],[R[55]]],[R[55]]]]],[11,"path_statistics",E,E,1,[[["self"]],["pathstatistics"]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[59],E,E,0,[[["self"]],[T]]],[11,R[60],E,E,0,[[["self"],[T]]]],[11,R[56],E,E,0,[[[U]],[R[51]]]],[11,R[57],E,E,0,[[],[R[51]]]],[11,R[63],E,E,0,[[["self"]],[T]]],[11,R[58],E,E,0,[[["self"]],[T]]],[11,R[61],E,E,0,[[["self"]],[R[64]]]],[11,"into",E,E,10,[[],[U]]],[11,"from",E,E,10,[[[T]],[T]]],[11,R[56],E,E,10,[[[U]],[R[51]]]],[11,R[57],E,E,10,[[],[R[51]]]],[11,R[63],E,E,10,[[["self"]],[T]]],[11,R[58],E,E,10,[[["self"]],[T]]],[11,R[61],E,E,10,[[["self"]],[R[64]]]],[11,"into",E,E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[59],E,E,6,[[["self"]],[T]]],[11,R[60],E,E,6,[[["self"],[T]]]],[11,R[62],E,E,6,[[["self"]],[R[65]]]],[11,R[56],E,E,6,[[[U]],[R[51]]]],[11,R[57],E,E,6,[[],[R[51]]]],[11,R[63],E,E,6,[[["self"]],[T]]],[11,R[58],E,E,6,[[["self"]],[T]]],[11,R[61],E,E,6,[[["self"]],[R[64]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[62],E,E,1,[[["self"]],[R[65]]]],[11,R[56],E,E,1,[[[U]],[R[51]]]],[11,R[57],E,E,1,[[],[R[51]]]],[11,R[63],E,E,1,[[["self"]],[T]]],[11,R[58],E,E,1,[[["self"]],[T]]],[11,R[61],E,E,1,[[["self"]],[R[64]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[56],E,E,2,[[[U]],[R[51]]]],[11,R[57],E,E,2,[[],[R[51]]]],[11,R[63],E,E,2,[[["self"]],[T]]],[11,R[58],E,E,2,[[["self"]],[T]]],[11,R[61],E,E,2,[[["self"]],[R[64]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[59],E,E,3,[[["self"]],[T]]],[11,R[60],E,E,3,[[["self"],[T]]]],[11,R[62],E,E,3,[[["self"]],[R[65]]]],[11,R[56],E,E,3,[[[U]],[R[51]]]],[11,R[57],E,E,3,[[],[R[51]]]],[11,R[63],E,E,3,[[["self"]],[T]]],[11,R[58],E,E,3,[[["self"]],[T]]],[11,R[61],E,E,3,[[["self"]],[R[64]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[59],E,E,4,[[["self"]],[T]]],[11,R[60],E,E,4,[[["self"],[T]]]],[11,R[56],E,E,4,[[[U]],[R[51]]]],[11,R[57],E,E,4,[[],[R[51]]]],[11,R[63],E,E,4,[[["self"]],[T]]],[11,R[58],E,E,4,[[["self"]],[T]]],[11,R[61],E,E,4,[[["self"]],[R[64]]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[56],E,E,5,[[[U]],[R[51]]]],[11,R[57],E,E,5,[[],[R[51]]]],[11,R[63],E,E,5,[[["self"]],[T]]],[11,R[58],E,E,5,[[["self"]],[T]]],[11,R[61],E,E,5,[[["self"]],[R[64]]]],[11,"into",R[66],E,7,[[],[U]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[56],E,E,7,[[[U]],[R[51]]]],[11,R[57],E,E,7,[[],[R[51]]]],[11,R[63],E,E,7,[[["self"]],[T]]],[11,R[58],E,E,7,[[["self"]],[T]]],[11,R[61],E,E,7,[[["self"]],[R[64]]]],[11,"into",E,E,8,[[],[U]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[59],E,E,8,[[["self"]],[T]]],[11,R[60],E,E,8,[[["self"],[T]]]],[11,R[56],E,E,8,[[[U]],[R[51]]]],[11,R[57],E,E,8,[[],[R[51]]]],[11,R[63],E,E,8,[[["self"]],[T]]],[11,R[58],E,E,8,[[["self"]],[T]]],[11,R[61],E,E,8,[[["self"]],[R[64]]]],[11,"into",R[52],E,11,[[],[U]]],[11,"from",E,E,11,[[[T]],[T]]],[11,R[59],E,E,11,[[["self"]],[T]]],[11,R[60],E,E,11,[[["self"],[T]]]],[11,R[56],E,E,11,[[[U]],[R[51]]]],[11,R[57],E,E,11,[[],[R[51]]]],[11,R[63],E,E,11,[[["self"]],[T]]],[11,R[58],E,E,11,[[["self"]],[T]]],[11,R[61],E,E,11,[[["self"]],[R[64]]]],[11,"into",E,E,12,[[],[U]]],[11,"from",E,E,12,[[[T]],[T]]],[11,R[59],E,E,12,[[["self"]],[T]]],[11,R[60],E,E,12,[[["self"],[T]]]],[11,R[56],E,E,12,[[[U]],[R[51]]]],[11,R[57],E,E,12,[[],[R[51]]]],[11,R[63],E,E,12,[[["self"]],[T]]],[11,R[58],E,E,12,[[["self"]],[T]]],[11,R[61],E,E,12,[[["self"]],[R[64]]]],[11,"into",E,E,13,[[],[U]]],[11,"from",E,E,13,[[[T]],[T]]],[11,R[59],E,E,13,[[["self"]],[T]]],[11,R[60],E,E,13,[[["self"],[T]]]],[11,R[56],E,E,13,[[[U]],[R[51]]]],[11,R[57],E,E,13,[[],[R[51]]]],[11,R[63],E,E,13,[[["self"]],[T]]],[11,R[58],E,E,13,[[["self"]],[T]]],[11,R[61],E,E,13,[[["self"]],[R[64]]]],[11,"into",E,E,9,[[],[U]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[59],E,E,9,[[["self"]],[T]]],[11,R[60],E,E,9,[[["self"],[T]]]],[11,R[56],E,E,9,[[[U]],[R[51]]]],[11,R[57],E,E,9,[[],[R[51]]]],[11,R[63],E,E,9,[[["self"]],[T]]],[11,R[58],E,E,9,[[["self"]],[T]]],[11,R[61],E,E,9,[[["self"]],[R[64]]]],[11,"clone",R[1],E,0,[[["self"]],[R[6]]]],[11,"default",E,"Default values for all configuration parameters.",0,[[],[R[6]]]],[11,"as_ref",R[52],E,11,[[["self"]],["btor"]]],[11,"from",E,E,11,[[["btor"],["rc",["btor"]]],[R[68]]]],[11,"clone",R[1],E,3,[[["self"]],[R[49]]]],[11,"clone",E,E,6,[[["self"]],[R[45]]]],[11,"clone",E,E,4,[[["self"]],[R[8]]]],[11,"clone",R[66],E,8,[[["self"]],[R[67]]]],[11,"clone",R[52],E,11,[[["self"]],[R[68]]]],[11,"clone",E,E,9,[[["self"]],["bv"]]],[11,"clone",E,E,12,[[["self"]],["memory"]]],[11,"clone",E,E,13,[[["self"]],[R[4]]]],[11,"eq",R[1],E,3,[[[R[49]],["self"]],["bool"]]],[11,"ne",E,E,3,[[[R[49]],["self"]],["bool"]]],[11,"eq",E,E,6,[[[R[45]],["self"]],["bool"]]],[11,"ne",E,E,6,[[[R[45]],["self"]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[8]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[8]]],["bool"]]],[11,"eq",R[66],E,8,[[["self"],[R[67]]],["bool"]]],[11,"ne",E,E,8,[[["self"],[R[67]]],["bool"]]],[11,"eq",R[52],E,11,[[[R[68]],["self"]],["bool"]]],[11,"ne",E,E,11,[[[R[68]],["self"]],["bool"]]],[11,"eq",E,E,9,[[["bv"],["self"]],["bool"]]],[11,"ne",E,E,9,[[["bv"],["self"]],["bool"]]],[11,"eq",E,E,12,[[["memory"],["self"]],["bool"]]],[11,"ne",E,E,12,[[["memory"],["self"]],["bool"]]],[11,"fmt",R[1],E,3,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,6,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,1,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,3,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,6,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,4,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",R[66],E,8,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",R[52],E,11,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,9,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,12,[[["self"],[R[69]]],[R[51]]]],[11,"fmt",E,E,13,[[["self"],[R[69]]],[R[51]]]],[11,"deref",E,E,11,[[["self"]],["btor"]]],[11,"new",E,E,11,[[],["self"]]],[11,"duplicate",E,E,11,[[["self"]],["self"]]],[11,"match_bv",E,E,11,[[["bv"],["self"]],[[R[54],["bv"]],["bv"]]]],[11,"match_array",E,E,11,[[["self"],["array"]],[[R[54],["array"]],["array",["rc"]]]]],[11,"new",E,E,9,[[["str"],["u32"],[R[54],["str"]],[R[68]]],["self"]]],[11,"from_bool",E,E,9,[[["bool"],[R[68]]],["self"]]],[11,"from_i32",E,E,9,[[["i32"],["u32"],[R[68]]],["self"]]],[11,"from_u32",E,E,9,[[["u32"],[R[68]]],["self"]]],[11,"from_i64",E,E,9,[[["i64"],["u32"],[R[68]]],["self"]]],[11,"from_u64",E,E,9,[[["u32"],["u64"],[R[68]]],["self"]]],[11,"zero",E,E,9,[[["u32"],[R[68]]],["self"]]],[11,"one",E,E,9,[[["u32"],[R[68]]],["self"]]],[11,"ones",E,E,9,[[["u32"],[R[68]]],["self"]]],[11,"from_binary_str",E,E,9,[[["str"],[R[68]]],["self"]]],[11,"from_dec_str",E,E,9,[[["str"],["u32"],[R[68]]],["self"]]],[11,"from_hex_str",E,E,9,[[["str"],["u32"],[R[68]]],["self"]]],[11,"as_binary_str",E,E,9,[[["self"]],[[R[54],[R[65]]],[R[65]]]]],[11,"as_u64",E,E,9,[[["self"]],[[R[54],["u64"]],["u64"]]]],[11,"as_bool",E,E,9,[[["self"]],[[R[54],["bool"]],["bool"]]]],[11,"get_a_solution",E,E,9,[[["self"]],[[R[70]],[R[51],[R[70]]]]]],[11,R[71],E,E,9,[[["self"]]]],[11,"get_id",E,E,9,[[["self"]],["i32"]]],[11,"get_width",E,E,9,[[["self"]],["u32"]]],[11,"get_symbol",E,E,9,[[["self"]],[["str"],[R[54],["str"]]]]],[11,"set_symbol",E,E,9,[[["str"],["self"],[R[54],["str"]]]]],[11,"is_const",E,E,9,[[["self"]],["bool"]]],[11,"has_same_width",E,E,9,[[["self"]],["bool"]]],[11,"assert",E,E,9,[[["self"]],[R[51]]]],[11,"is_failed_assumption",E,E,9,[[["self"]],["bool"]]],[11,"_eq",E,E,9,[[["self"]],["self"]]],[11,"_ne",E,E,9,[[["self"]],["self"]]],[11,"add",E,E,9,[[["self"]],["self"]]],[11,"sub",E,E,9,[[["self"]],["self"]]],[11,"mul",E,E,9,[[["self"]],["self"]]],[11,"udiv",E,E,9,[[["self"]],["self"]]],[11,"sdiv",E,E,9,[[["self"]],["self"]]],[11,"urem",E,E,9,[[["self"]],["self"]]],[11,"srem",E,E,9,[[["self"]],["self"]]],[11,"smod",E,E,9,[[["self"]],["self"]]],[11,"inc",E,E,9,[[["self"]],["self"]]],[11,"dec",E,E,9,[[["self"]],["self"]]],[11,"neg",E,E,9,[[["self"]],["self"]]],[11,"uaddo",E,E,9,[[["self"]],["self"]]],[11,"saddo",E,E,9,[[["self"]],["self"]]],[11,"usubo",E,E,9,[[["self"]],["self"]]],[11,"ssubo",E,E,9,[[["self"]],["self"]]],[11,"umulo",E,E,9,[[["self"]],["self"]]],[11,"smulo",E,E,9,[[["self"]],["self"]]],[11,"sdivo",E,E,9,[[["self"]],["self"]]],[11,"not",E,E,9,[[["self"]],["self"]]],[11,"and",E,E,9,[[["self"]],["self"]]],[11,"or",E,E,9,[[["self"]],["self"]]],[11,"xor",E,E,9,[[["self"]],["self"]]],[11,"nand",E,E,9,[[["self"]],["self"]]],[11,"nor",E,E,9,[[["self"]],["self"]]],[11,"xnor",E,E,9,[[["self"]],["self"]]],[11,"sll",E,E,9,[[["self"]],["self"]]],[11,"srl",E,E,9,[[["self"]],["self"]]],[11,"sra",E,E,9,[[["self"]],["self"]]],[11,"rol",E,E,9,[[["self"]],["self"]]],[11,"ror",E,E,9,[[["self"]],["self"]]],[11,"redand",E,E,9,[[["self"]],["self"]]],[11,"redor",E,E,9,[[["self"]],["self"]]],[11,"redxor",E,E,9,[[["self"]],["self"]]],[11,"ugt",E,E,9,[[["self"]],["self"]]],[11,"ugte",E,E,9,[[["self"]],["self"]]],[11,"sgt",E,E,9,[[["self"]],["self"]]],[11,"sgte",E,E,9,[[["self"]],["self"]]],[11,"ult",E,E,9,[[["self"]],["self"]]],[11,"ulte",E,E,9,[[["self"]],["self"]]],[11,"slt",E,E,9,[[["self"]],["self"]]],[11,"slte",E,E,9,[[["self"]],["self"]]],[11,"uadds",E,E,9,[[["self"]],["self"]]],[11,"sadds",E,E,9,[[["self"]],["self"]]],[11,"usubs",E,E,9,[[["self"]],["self"]]],[11,"ssubs",E,E,9,[[["self"]],["self"]]],[11,"zext",E,E,9,[[["u32"],["self"]],["self"]]],[11,"sext",E,E,9,[[["u32"],["self"]],["self"]]],[11,"slice",E,E,9,[[["u32"],["self"]],["self"]]],[11,"concat",E,E,9,[[["self"]],["self"]]],[11,"repeat",E,E,9,[[["u32"],["self"]],["self"]]],[11,"iff",E,E,9,[[["self"]],["self"]]],[11,"implies",E,E,9,[[["self"]],["self"]]],[11,"cond_bv",E,E,9,[[["self"]],["self"]]],[11,"new_uninitialized",E,E,12,[[["str"],[R[68]],[R[54],["str"]],["bool"]],["self"]]],[11,"new_zero_initialized",E,E,12,[[["str"],[R[68]],[R[54],["str"]],["bool"]],["self"]]],[11,"read",E,E,12,[[["u32"],["self"]],[R[51]]]],[11,"write",E,E,12,[[["self"]],[R[51]]]],[11,R[71],E,E,12,[[["self"]],[R[68]]]],[11,"change_solver",E,E,12,[[["self"],[R[68]]]]],[11,"new",R[1],"Creates a new `Config` with the given `loop_bound`,…",0,[[[R[54],[R[72]]],[R[72]],["usize"],["concretize"],["bool"]],[R[6]]]],[11,"from_bc_path",E,"Construct a new `Project` from a path to an LLVM bitcode…",10,[[],[[R[5]],[R[65]],[R[51],[R[5],R[65]]]]]],[11,"from_bc_paths",E,"Construct a new `Project` from multiple LLVM bitcode files",10,[[],[[R[5]],[R[65]],[R[51],[R[5],R[65]]]]]],[11,"from_bc_dir",E,R[73],10,[[["str"]],[["error"],[R[51],[R[5],"error"]],[R[5]]]]],[11,"from_bc_dir_with_blacklist",E,R[73],10,[[["str"]],[["error"],[R[51],[R[5],"error"]],[R[5]]]]],[11,"add_bc_path",E,"Add the code in the given LLVM bitcode file to the `Project`",10,[[["self"]],[[R[51],[R[65]]],[R[65]]]]],[11,"add_bc_dir",E,"Add the code in the given directory to the `Project`. See…",10,[[["str"],["self"]],[["error"],[R[51],["error"]]]]],[11,"add_bc_dir_with_blacklist",E,"Add the code in the given directory, except for…",10,[[["str"],["self"]],[["error"],[R[51],["error"]]]]],[11,"all_functions",E,"Iterate over all `Function`s in the `Project`. Gives pairs…",10,[[["self"]]]],[11,"all_global_vars",E,"Iterate over all `GlobalVariable`s in the `Project`. Gives…",10,[[["self"]]]],[11,"all_global_aliases",E,"Iterate over all `GlobalAlias`es in the `Project`. Gives…",10,[[["self"]]]],[11,"all_named_struct_types",E,"Iterate over all named struct types in the `Project`.…",10,[[["self"]]]],[11,"active_module_names",E,"Get the names of the LLVM modules which have been parsed…",10,[[["self"]]]],[11,"get_func_by_name",E,"Search the project for a function with the given name. If…",10,[[["str"],["self"]],[R[54]]]],[11,"get_named_struct_type_by_name",E,"Search the project for a named struct type with the given…",10,[[["str"],["self"]],[R[54]]]],[11,"get_inner_struct_type_from_named",E,"Given a `NamedStructType`, get the `StructType`…",10,[[["type"],["self"]],[[R[54],["arc"]],["arc",["rwlock"]]]]]],"p":[[3,"Config"],[3,R[74]],[3,R[75]],[4,R[76]],[4,R[77]],[4,R[78]],[3,R[79]],[3,"Context"],[3,R[80]],[4,"BV"],[3,"Project"],[3,"BtorRef"],[3,"Memory"],[3,"Backend"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);